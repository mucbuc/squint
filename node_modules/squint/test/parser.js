var assert = require( 'assert' )
  , Parser = require( 'squint/parser' ).Parser;

function TestParser() {
  var expectations = [];

  Parser.call( this );   

  process.on( 'exit', function() {
    assert.equal( expectations.length, 0 );
  } );

  function check( code ) {
    var expectation = expectations[0];
    expectations.splice( 0, 1 );
   
    if (expectation.code != undefined) {
      assert.equal( code, expectation.code );
    }
    
    if (expectations.length) {
      this.once( expectations[0].event, check );
    }
  }

  this.expect = function( event, code ) {
    if (!expectations.length) {
      this.once( event, check );
    }
    expectations.push( { event: event, code: code } );
  }; 
};

TestParser.prototype = new Parser();

testNested();
testInterleaved();
testScopes();
testStatments();

function testNested() {
  var parser = new TestParser();

  parser.expect( 'open', 'a' );
  parser.expect( 'open', 'b' );
  parser.expect( 'statement', 'c' );
  parser.expect( 'close' );
  parser.expect( 'close' );

  parser.parse( 'a { b { c; } }' );
};

function testInterleaved() { 
  var parser = new TestParser();
  
  parser.expect( 'open', 'a' );
  parser.expect( 'statement','b' );
  parser.expect( 'close' );
   
  parser.parse( 'a{ b; }' );
}

function testScopes() {
  var parser = new TestParser();
  
  parser.expect( 'open', 'a' ); 
  parser.expect( 'close' );
  parser.expect( 'open', 'b' );
  parser.expect( 'close' );
  parser.expect( 'open', 'c' );
  parser.expect( 'close' );
 
  parser.parse( 'a{} b{} c{}' );
}

function testStatments() {
  var parser = new TestParser();

  parser.expect( 'statement', '1' );
  parser.expect( 'statement', '2' );
  parser.expect( 'statement', '3' );
  parser.expect( 'statement' );
 
  parser.parse( '1; 2; 3;;' );
}
